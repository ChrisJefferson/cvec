Cases for scalars:
 Internally handled:
  size=0 or size=1:
   * IsFFE and IsInternalRep direkt
   * IsInt  (0<=s<p als ImmediateInt)
   * IsInt  (0<=s<q als ImmediateInt)
  size=2:
   * IsList (of immediate Integers, 0<=c<p)
   * IsList (of IsFFE and IsInternalRep)
     hier ist Problem: koennte Tabellen fuer Primkoerper brauchen!
     ==> Mache Primkoerper und tab1 und tab2, wenn p < 65536
 ==> handle_scalar muss jeweils alles koennen, Liste darf zu kurz sein, wird
     dann mit Nullen aufgefuellt.
 GAP-level:
   * IsFFE and IsInternalRep  -->  direkt
   * IsFFE and IsZmodnZObj  -->  uebersetze in Int durch ![1]
   * IsFFE (Steve's large scalars):
     --> setze auf ![1] um, verschiedene Moeglichkeiten:
     - IsGF2VectorRep --> rufe ShallowCopy und PLAIN_GF2VEC
     - Is8bitVectorRep --> rufe ShallowCopy und PLAIN_8BITVEC
     - Sonst:
       . p < MAXSIZE_GF_INTERNAL --> direkt
       . p >= --> rufe List(v->v![1])

Creation of scalars:
  \[\] for cvecs
  Unpack
  FFEList --> Some postprocessing in GAP necessary

Rascher input von Steve's Skalaren
Rascher output von Steve's Skalaren
bequeme Methodeninstallation

Grossreinemachen:
  - Skalare raus (nur letzte Version von ProductCoeffs (primkoerper) drin
  - cvecclasses aufraeumen
  - input/output von Skalaren aufraeumen
  - Wurzeln raus --> Steve
  - Doku von Skalaren raus

TODO aufraeumen:

[] liefert neue CScas fuer q>65536 ==> insbesondere d=1
Assignment fuer Vektoren OK?
aus/einpacken


Make integers as scalars behave like mod p or like p-adic expansion?
Make CopySubmatrix an operation?
Is -m!.rows a good way for AdditiveInverse of Matrix?

Tasks to do:

  * Concatenation fuer CVecs
  * TransposedMat
  * InverseMat
  * matrix.g{d,i} look through for usability
  * test DeterminantMat
  * IsMutable-Durchgang durch cvec.gi
  * Beweis, dass keine CHANGED_BAGs fehlen
  * Documentation
  * Cleanup of "Hacks" and "Utilities" in cvec.gi
  * Hash-Funktionen fuer Matrizen und Vektoren (Generators?)

Future plans:

  * Sort for CMats, 
  * DistanceVecFFE
  * NumberFFVector
  * Weitere Wurzeln, Sqrt in Ordnung bringen
  * CVec creation method for list of our scalars
  * other polynomials than conway

Possibly not to do:

  * ADDMUL3 auf GAP-Ebene fuer \- ?
  * C-Mtx-binary-format R/W
  * Append for CVecs
  * Resize for CVecs
  * Generic Sequential access, at least for prime field
  * folding for polynomial code
  * * mod cp, at least over prime field
  * CVecClass as a constructor operation also for scalars
  * GAP-Lib: GF, LargeGaloisField --> operationen --> 4.4
  * Resize of vectors / locked vectors?
  * Sort out finite field business: own Cscas?
  * PrimitiveRoot for d=1 ==> factorize p-1 and search
Inverse fuer d=1 testen (mod p)
Inverse fuer d>1 testen, debuggen
neue Methoden: Polynomdiv, euklid. algorithmus, invertieren
CSca methoden korrekt: *, /, ^-1
Scalartests zum Laufen bringen
polynomarith mit worten fuer prime field els raus
wurzeln besser

Done:

  * ADDMUL2, ADDMUL3 (for AddRowVector and SumRowVector)
  * GET_ELM, ASS_ELM
  * FFE_TO_INT
  * FIRST_NONZERO
  * COMPARE
  * GAP-Level:
    - AddRowVector, MulRowVector, +, *, ConvertToVectorRep,
      ConvertToIntRep, PositionNonZero, 
      (mutability!)
    - Assignment, element access, <, =
  * Characteristic
  * DegreeFFE
  * BaseField
  * PrintObj and Display
  * scalars
  * Matrices auf GAP-Ebene:
    Creation, 
    Add, 
    Remove, 
    Rowaccess (R/W), 
    Append, 
    Concatenation,
    Slicing, 
    IsBound, 
    Unbind (only at end)
    ViewObj, PrintObj, Display
    addition, negation, subtraction,
    multiplication with scalars
  * vector * matrix
  * Greasing-Helper (C)
  * matrix multiplication on GAP-level with grease
  * matrix multiplication, if not greased
  * vector * matrix in C
  * SLICE(v,w,start,end,dest)
  * Slicing, Slicing-Assignment on GAP-level
  * Extrep (C), I/O
  * RankMat testen
  * SemiEchelonMat and friends testen
  * GAP-Lib: MutableCopyMat, 
  * CVec Method for only a cvecclass in addition to CVEC.New
