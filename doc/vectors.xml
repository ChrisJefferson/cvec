<!-- 

  vectors.xml            cvec package documentation           Max Neunhoeffer

         Copyright (C) 2005, Lehrstuhl D für Mathematik, RWTH-Aachen

This chapter covers compressed vectors.

-->

<Chapter Label="vectors">
<Heading>Vectors</Heading>

See Section <Ref Sect="cvecs"/> for a documentation of the data format
of <C>cvec</C>s and its restrictions.<P/>

<Section>
<Heading>Creation</Heading>

Note that many functions described later in this chapter implicitly 
create new <C>cvec</C>s, such that it is usually only in the beginning
of a calculation necessary to create <C>cvec</C>s explicitly.

<ManSection>
<Oper Name="CVec" Arg="arg"/>
<Returns>a new mutable <C>cvec</C></Returns>
<Description>
    Creates a new <C>cvec</C>. See the method descriptions for details.
</Description>
</ManSection>

<ManSection>
<Meth Name="CVec" Arg="cvecclass" Label="cvecclass"/>
<Returns>a new mutable <C>cvec</C></Returns>
<Description>
    <A>cvecclass</A> must be a <C>cvecclass</C>. Creates a new
    <C>cvec</C> containing only zeroes. For an explanation of the term
    <C>cvecclass</C> see Section <Ref Sect="cvecs"/> and 
    <Ref Oper="CVecClass"/>. 
</Description>
</ManSection>

<ManSection>
<Meth Name="CVec" Arg="coeffs, cvecclass" Label="coeffl_cvecclass"/>
<Returns>a new mutable <C>cvec</C></Returns>
<Description>
    This method takes a coefficient list and a <C>cvecclass</C>
    as arguments. Assume the vector will be over <M>GF(p,d)</M> with
    <M>q=p^d</M>. For the coefficient list <A>coeffs</A> there exist
    several possibilities, partially depending on the base field size. 
    If <M>q=p^d \leq 65536</M>, the easiest way is to use &GAP; finite
    field elements, which will be put into the new vector in the same 
    order. If <M>d=1</M>, one can always use &GAP; immediate integers
    between <M>0</M> and <M>p-1</M>, the vector will then contain the 
    corresponding cosets in <M>GF(p)=Z/pZ</M>. If <M>q</M> is small enough
    to be a &GAP; immediate integer, then one can use &GAP; immediate
    integers that are equal to the <M>p</M>-adic expansion using the
    coefficients of the representing polynomial as coefficients. That is,
    if an element in <M>GF(p,d)</M> is represented by the polynomial
    <M>\sum_{{i=0}}^{{d-1}} a_i x^i</M> with <M>a_i \in \{0,\ldots,p-1\}</M>,
    then one has to put <M>\sum_{{i=0}}^{{d-1}} a_i p^i</M> as integer into 
    the coefficient list <A>coeffs</A>. If <M>q</M> is larger, then
    <A>coeffs</A> is a list of length <M>d</M> times the length of the
    new <C>cvec</C> and contains for each field element of <M>GF(p,d)</M> 
    in the vector its <M>d</M> coefficients of the representing polynomial.
    As of this writing, a list of <C>csca</C>s is not supported as
    first argument, which might change over time.<P/>
    For an explanation of the term <C>cvecclass</C> see Section <Ref
    Sect="cvecs"/> and <Ref Oper="CVecClass"/>. Of course, the length of
    the list <A>coeffs</A> must match the length of the vector given in the
    <C>cvecclass</C>.
</Description>
</ManSection>

<ManSection>
<Meth Name="CVec" Arg="coeffs, p, d" Label="coeffl_p_d"/>
<Returns>a new mutable <C>cvec</C></Returns>
<Description>
    This method takes a coefficient list and two positive integers
    <A>p</A> and <A>d</A> as arguments. A new <C>cvec</C> over <M>GF(p,d)</M>
    will be created. Let <M>q := p^d</M>.<P/>
    For a description of the possible values of the coefficient list 
    <A>coeffs</A> see the description of the method <Ref Meth="CVec"
    Label="coeffl_cvecclass"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="CVec" Arg="v" Label="compvec"/>
<Returns>a new <C>cvec</C></Returns>
<Description>
    <A>v</A> must be a &GAP; compressed vector either over <M>GF(2)</M> or
    <M>GF(p,d)</M> with <M>p^d \leq 256</M>. Creates a new
    <C>cvec</C> containing the same numbers as <A>v</A> over the field
    which the <C>Field</C> operation returns for <A>v</A>.
</Description>
</ManSection>

After having encountered the concept of a <C>cvecclass</C> already
a few times it is time to learn how to create one. The following
operation is used first to create new <C>cvecclass</C>es and second
to ask a <C>cvec</C> for its class. In addition, it is used for
<C>csca</C>s.

<ManSection>
<Oper Name="CVecClass" Arg="arg"/>
<Returns>a <C>cvecclass</C></Returns>
<Description>
Creates new <C>cvecclass</C>es and asks <C>csca</C>s and <C>cvec</C>s
for their class. See the following method descriptions for details.
For an explanation of the term <C>cvecclass</C> see Section <Ref
Sect="cvecs"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="CVecClass" Arg="p, d, l"/>
<Returns>a <C>cvecclass</C> or a <C>cscaclass</C></Returns>
<Description>
All three arguments must be integers. The arguments <A>p</A> and <A>d</A>
must be positive and describe the base field <M>GF(p,d)</M>. The third
argument must either be positive, in which case the method returns
the <C>cvecclass</C> of vectors over <M>GF(p,d)</M> of length <A>l</A>,
or equal to <M>-1</M>, in which case the method returns the class of
<C>csca</C>s in <M>GF(p,d)</M>. Note that this is also possible to
do for <M>p^d \leq 65536</M>, although this probably will not make much
sense, as &GAP; finite field elements will be more efficient in nearly
all applications.<P/>
For an explanation of the term <C>cvecclass</C> and its data structure
see Section <Ref Sect="cvecs"/>, for <C>cscaclass</C> see Section
<Ref Sect="cscas"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="CVecClass" Arg="v"/>
<Returns>a <C>cvecclass</C> or a <C>cscaclass</C></Returns>
<Description>
The argument <A>v</A> must either be a <C>cvec</C> or a <C>csca</C>.
The method returns the corresponding <C>cvecclass</C> or <C>cscaclass</C>
respectively.
For an explanation of the term <C>cvecclass</C> and its data structure
see Section <Ref Sect="cvecs"/>, for <C>cscaclass</C> see Section
<Ref Sect="cscas"/>.
</Description>
</ManSection>

<ManSection>
<Meth Name="ZeroSameMutability" Arg="v" Label="cvec"/>
<Returns>The zero <C>cvec</C> in the same <C>cvecclass</C> as <A>v</A>.
</Returns>
<Description>
<A>v</A> must be a <C>cvec</C>.
</Description>
</ManSection>

<ManSection>
<Meth Name="ZeroMutable" Arg="v" Label="cvec"/>
<Returns>A mutable copy of the zero <C>cvec</C> in the same <C>cvecclass</C> 
as <A>v</A>.
</Returns>
<Description>
<A>v</A> must be a <C>cvec</C>.
</Description>
</ManSection>

<ManSection>
<Meth Name="ShallowCopy" Arg="v" Label="cvec"/>
<Returns>A mutable copy of <A>v</A>.
</Returns>
<Description>
<A>v</A> must be a <C>cvec</C>.
</Description>
</ManSection>

</Section>

<Section>
<Heading>Element access and unpacking</Heading>

</Section>

<Section>
<Heading>Arithmetic</Heading>

Of course, the standard arithmetic infix operations <M>+</M>, <M>-</M> and
<M>*</M> (for vectors and scalars) work as expected by using the  
methods below. We start this section with a subsection on the usage of
scalars in arithmetic operations involving vectors.

<Subsection Label="scahandl">
<Heading>Handling of scalars in arithmetic operations</Heading>

In all places (like in <C>\*</C>) where vectors and scalars occur, the
following conventions apply to scalars:<P/>

&GAP; finite field elements can be used as scalars as long as the vectors
are over a field <M>GF(p,d)</M> with <M>p^d \leq 65536</M>.<P/> 

Integers between <M>0</M> and <M>p-1</M> (inclusively) can always be used as
scalars representing prime field elements via the isomorphism 
<M>GF(p)=Z/pZ</M>, also for extension fields. Larger integers than
<M>p-1</M>, as long as they are &GAP; immediate integers, are interpreted 
as the <M>p</M>-adic expansion of the coefficient list of the polynomial
representing the scalar. Note that this usage of immediate integers
differs from the standard list arithmetic in &GAP; because multiplication
with the integer <M>n</M> not necessarily means the same than <M>n</M> times
addition! Larger integers than immediate integers are not supported.<P/>

Of course, <C>csca</C>s can always be used as scalars in arithmetic operations.
</Subsection>

<ManSection>
<Meth Name="\+" Arg="v, w" Label="cvec_cvec"/>
<Returns>The sum <M><A>v</A>+<A>w</A></M> as a new <C>cvec</C>.</Returns>
<Description>
    For two <C>cvec</C>s <A>v</A> and <A>w</A>. Works as expected.
</Description>
</ManSection>

<ManSection>
<Meth Name="\-" Arg="v, w" Label="cvec_cvec"/>
<Returns>The difference <M><A>v</A>-<A>w</A></M> as a new <C>cvec</C>.</Returns>
<Description>
    For two <C>cvec</C>s <A>v</A> and <A>w</A>. Works as expected.
</Description>
</ManSection>

<ManSection>
<Meth Name="AdditiveInverseSameMutability" Arg="v" Label="cvec"/>
<Returns>The additive inverse of <A>v</A> as a new <C>cvec</C>.</Returns>
<Description>
For a <C>cvec</C> <A>v</A>. Works as expected.
</Description>
</ManSection>

<ManSection>
<Meth Name="AdditiveInverseMutable" Arg="v" Label="cvec"/>
<Returns>The additive inverse of <A>v</A> as a new mutable <C>cvec</C>.
</Returns>
<Description>
For a <C>cvec</C> <A>v</A>. Works as expected.
</Description>
</ManSection>

<ManSection>
<Meth Name="\*" Arg="v, s" Label="cvec_sca"/>
<Meth Name="\*" Arg="s, v" Label="sca_cvec"/>
<Returns>The scalar multiple <A>s</A><M>\cdot</M><A>v</A>.</Returns>
<Description>
    For a <C>cvec</C> <A>v</A> and a scalar <A>s</A>. For the format
    of the scalar see <Ref Subsect="scahandl"/>. Works as expected.
</Description>
</ManSection>

<ManSection>
<Meth Name="AddRowVector" Arg="v, w, s" Label="cvec_cvec_sca"/>
<Meth Name="AddRowVector" Arg="v, w, s, fr, to" Label="cvec_cvec_sca_pos_pos"/>
<Returns>nothing</Returns>
<Description>
    <A>v</A> and <A>w</A> must be <C>cvec</C>s over the same field with
    equal length, <A>s</A> a scalar (see Subsection <Ref Subsect="scahandl"/>)
    and <A>v</A> must be mutable.
    Adds <A>s</A><M>\cdot</M><A>w</A> to <A>v</A> modifying <A>v</A>. If
    <A>fr</A> and <A>to</A> are given, they give a hint, that <A>w</A> is
    zero outside positions <A>fr</A> to <A>to</A> (inclusively). The method
    can, if it chooses so, save time by not computing outside that range.
    In fact, the implemented method restricts the operation to the
    <C>Word</C>s involved.<P/>
    If either <A>fr</A> or <A>to</A> is <M>0</M> it defaults to <M>1</M> and
    <C>Length(v)</C> respectively.
</Description>
</ManSection>

<ManSection>
<Meth Name="MultRowVector" Arg="v, s" Label="cvec_sca"/>
<Meth Name="AddRowVector" Arg="v, s, fr, to" Label="cvec_sca_pos_pos"/>
<Returns>nothing</Returns>
<Description>
    <A>v</A> must be a mutable <C>cvec</C> and <A>s</A> a scalar (see
    Subsection <Ref Subsect="scahandl"/>).
    Multiplys <A>v</A> by <A>s</A> modifying <A>v</A>. If
    <A>fr</A> and <A>to</A> are given, they give a hint, that <A>v</A> is
    zero outside positions <A>fr</A> to <A>to</A> (inclusively). The method
    can, if it chooses so, save time by not computing outside that range.
    In fact, the implemented method restricts the operation to the
    <C>Word</C>s involved.<P/>
    If either <A>fr</A> or <A>to</A> is <M>0</M> it defaults to <M>1</M> and
    <C>Length(v)</C> respectively.
</Description>
</ManSection>
</Section>

<Section>
<Heading>Slicing</Heading>

</Section>

<Section>
<Heading>Access to the base field</Heading>

<ManSection>
<Meth Name="BaseField" Arg="v" Label="cvec"/>
<Returns>Returns the base field of <A>v</A>.
</Returns>
<Description>
    For a <C>cvec</C> <A>v</A>. For <M>q=p^d \leq 65536</M> this returns
    the &GAP; object <C>GF(p,d)</C>. For larger finite fields this
    uses the &GAP; library to form a field object, which basically only
    knows its <C>Size</C> and finiteness, <C>Zero</C> and <C>One</C>.
    One can probably not do much more with this. One can form
    a polynomial ring over it.
</Description>
</ManSection>

</Section>

<!-- ############################################################ -->

</Chapter>
